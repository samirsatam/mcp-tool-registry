# Database Migration Example

This document demonstrates how to add a new field to the tools table using the migration system.

## Scenario

We want to add a `category` field to the tools table to categorize tools (e.g., "utility", "data", "ai", etc.).

## Step 1: Update the Model

Edit `src/mcp_tool_registry/models.py`:

```python
class Tool(Base):
    """SQLAlchemy model for MCP tools."""

    __tablename__ = "tools"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(255), unique=True, index=True, nullable=False)
    version = Column(String(50), nullable=False)
    description = Column(Text, nullable=True)
    category = Column(String(100), nullable=True)  # NEW FIELD
    schema = Column(Text, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
```

Also update the Pydantic models:

```python
class ToolCreate(BaseModel):
    """Pydantic model for creating a new tool."""

    name: str = Field(..., min_length=1, max_length=255, description="Tool name")
    version: str = Field(..., min_length=1, max_length=50, description="Tool version")
    description: Optional[str] = Field(None, description="Tool description")
    category: Optional[str] = Field(None, max_length=100, description="Tool category")  # NEW FIELD
    schema: Dict[str, Any] = Field(..., description="Tool JSON schema")
```

## Step 2: Generate Migration

```bash
uv run mcp-cli db revision -m "Add category field to tools table"
```

This creates a new migration file in `migrations/versions/` with a name like:
`2025_09_25_1545_add_category_field_to_tools_table.py`

The naming format includes:
- **Date**: `2025_09_25` (YYYY_MM_DD)
- **Time**: `1545` (HHMM)
- **Description**: `add_category_field_to_tools_table`

**Note**: The filename is human-readable, but the file still contains an internal revision ID (like `a2c5f6ed102e`) that Alembic uses for tracking dependencies and rollbacks.

## Step 3: Review the Generated Migration

The generated migration should look like:

```python
def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('tools', sa.Column('category', sa.String(length=100), nullable=True))
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('tools', 'category')
    # ### end Alembic commands ###
```

## Step 4: Apply the Migration

```bash
uv run mcp-cli db upgrade
```

## Step 5: Verify the Migration

```bash
# Check current revision
uv run mcp-cli db current

# View migration history
uv run mcp-cli db history
```

## Step 6: Test the Changes

```bash
# Run tests to ensure everything works
uv run pytest -v

# Test the API with the new field
curl -X POST "http://localhost:8000/tools" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "example_tool",
    "version": "1.0.0",
    "description": "An example tool",
    "category": "utility",
    "schema": {
      "type": "object",
      "properties": {
        "input": {"type": "string"}
      }
    }
  }'
```

## Rollback (if needed)

If you need to rollback the migration:

```bash
# Find the previous revision ID
uv run mcp-cli db history

# Downgrade to the previous revision
uv run mcp-cli db downgrade --revision <previous_revision_id>
```

## Best Practices

1. **Always review** generated migrations before applying them
2. **Test migrations** on a copy of production data first
3. **Backup your database** before running migrations in production
4. **Commit migration files** to version control
5. **Use descriptive messages** when creating migrations
6. **Test both upgrade and downgrade** paths when possible